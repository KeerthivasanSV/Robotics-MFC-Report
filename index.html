<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta content="" name="description">
    <meta content="" name="author">
    
    <meta name="experiment-short-name" content="pvc-hot-water-coupling">
    <meta name="developer-institute" content="Amrita Vishwa Vidyapeetham">
    <meta name="learning-unit" content="Automated PVC Hot Water Coupling Using AI & Robotics">
    <meta name="task-name" content="Theory">
    
    <title>Automated PVC Hot Water Coupling Using AI & Robotics</title>
    <link rel="shortcut icon" href="./assets/images/favicon.ico">
    <link rel="stylesheet" href="./assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&family=Raleway&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./assets/fonts/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="./assets/css/github-markdown.min.css">
    <link rel="stylesheet" href="./assets/css/vlabs-style.css">
    <link rel="stylesheet" href="./assets/css/toast.css">
    <link rel="stylesheet" href="./assets/katex_assets/katex.min.css">
    
    <script src="./assets/js/jquery-3.4.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
      /* Blue-based color scheme */
      :root {
        --primary-blue: #1a73e8;
        --secondary-blue: #4285f4;
        --light-blue: #e8f0fe;
        --dark-blue: #174ea6;
        --text-dark: #202124;
      }
      
      body {
        font-family: 'Open Sans', sans-serif;
        color: var(--text-dark);
      }
      
      h1 {
        font-size: 1.8rem;
        color: var(--primary-blue);
        margin-top: 2rem;
      }
      
      h2 {
        font-size: 1.4rem;
        color: var(--dark-blue);
      }
      
      h3 {
        font-size: 1.2rem;
        color: var(--dark-blue);
      }
      
      h2, h3 {
        font-weight: 800;
      }
      
      .navbar {
        background-color: var(--primary-blue) !important;
        color: white !important;
      }
      
      .nav-menu {
        background-color: var(--light-blue);
        border-right: 1px solid #ddd;
      }
      
      .nav-menu-body a {
        color: var(--dark-blue) !important;
        text-decoration: none;
        display: block;
        padding: 0.5rem 1rem;
        margin: 2px 0;
        border-radius: 4px;
        transition: background-color 0.3s;
      }
      
      .nav-menu-body a:hover {
        background-color: rgba(66, 133, 244, 0.1);
        font-weight: bold;
      }
      
      .vlabs-footer {
        background-color: var(--dark-blue) !important;
      }
      
      .code-block {
        background: #f8f9fa;
        padding: 10px 15px;
        border-radius: 4px;
        font-family: monospace;
        overflow-x: auto;
        margin-bottom: 20px;
        border-left: 4px solid var(--primary-blue);
      }
      
      .equation {
        padding: 10px;
        margin: 10px 0;
        background: #f9f9f9;
        border-left: 4px solid var(--primary-blue);
        text-align: center;
      }
      
      /* Add this new CSS for equations */
      .equation p {
        margin-bottom: 0.5rem;
      }
      
      .equation p:last-child {
        margin-bottom: 0;
      }
      
      /* Improve MathJax rendering */
      .MathJax {
        overflow-x: auto;
        overflow-y: hidden;
        max-width: 100%;
      }
      
      .team-member {
        margin-bottom: 15px;
      }
      
      .method-section {
        margin-bottom: 30px;
      }
      
      .algorithm-box {
        border: 1px solid #e0e0e0;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        background-color: #f8f9fa;
        border-left: 4px solid var(--primary-blue);
      }
      
      .algorithm-box h4 {
        color: var(--primary-blue);
        margin-top: 0;
      }
      
      .feature-list {
        list-style-type: none;
        padding-left: 0;
      }
      
      .feature-list li {
        padding: 5px 0;
        padding-left: 25px;
        position: relative;
      }
      
      .feature-list li:before {
        content: "🔹";
        position: absolute;
        left: 0;
        color: var(--primary-blue);
      }
      
      .implementation-step {
        padding: 10px;
        margin-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      
      .data-flow-diagram {
        width: 100%;
        max-width: 600px;
        margin: 20px auto;
        border: 1px solid #ddd;
        padding: 10px;
      }
      
      .literature-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }
      
      .literature-table th, .literature-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      
      .literature-table th {
        background-color: var(--light-blue);
        color: var(--dark-blue);
      }
      
      /* New left navigation styling */
      .sidebar-nav {
        position: sticky;
        top: 0;
        background: var(--light-blue);
        border-right: 1px solid #ddd;
        height: 100vh;
        overflow-y: auto;
        padding: 1rem 0;
      }
      
      .chapter-link {
        display: block;
        padding: 0.5rem 1rem;
        color: var(--dark-blue);
        text-decoration: none;
        border-left: 4px solid transparent;
        transition: all 0.2s;
      }
      
      .chapter-link:hover, .chapter-link:focus {
        background-color: rgba(66, 133, 244, 0.1);
        border-left-color: var(--primary-blue);
        font-weight: bold;
      }
      
      .page-title {
        color: var(--primary-blue);
        padding: 1rem;
        font-weight: bold;
        font-size: 1.1rem;
      }
      
      .course-info {
        color: var(--dark-blue);
        font-size: 0.9rem;
        padding: 0 1rem 1rem;
        margin-bottom: 1rem;
        border-bottom: 1px solid #ddd;
      }
    </style>
</head>

<body class="p-0 container-fluid vlabs-page d-flex flex-column justify-content-between">
    <header class="vlabs-header sticky-top bg-white">
        <nav class="p-0 navbar navbar-light d-flex align-items-stretch" style="background-color: #1a73e8 !important;">
            <div class="d-flex justify-content-center w-100 align-items-center p-3">
                <span class="text-white font-weight-bold">Automated PVC Hot Water Coupling Using AI & Robotics</span>
            </div>
        </nav>
    </header>

    <div class="container-fluid flex-fill d-flex flex-column vlabs-page-main">
        <div class="row flex-grow-1 d-flex flex-nowrap flex-column flex-lg-row">
            <div class="col-lg-3 col-xl-2 sidebar-nav d-none d-lg-block" id="menu">
                <div class="page-title">MFC ROBOTICS - Group 9</div>
                <div class="course-info">
                    22MAT230: Mathematics for Computing<br>
                    22AlE214: Introduction to Al & Robotics
                </div>
                
                <a href="#introduction" class="chapter-link">1. Introduction</a>
                <a href="#problem-statement" class="chapter-link">2. Problem Statement</a>
                <a href="#proposed-solution" class="chapter-link">3. Proposed Solution</a>
                <a href="#methodology" class="chapter-link">4. Methodology</a>
                <a href="#technical-implementation" class="chapter-link">5. Technical Implementation</a>
                <a href="#progress-and-challenges" class="chapter-link">6. Progress and Challenges</a>
                <a href="#literature-review" class="chapter-link">7. Literature Review</a>
                <a href="#advanced-mathematical-foundations" class="chapter-link">8. Advanced Mathematical Foundations</a>
                <a href="#experimental-results" class="chapter-link">9. Experimental Results</a>
                <a href="#conclusion" class="chapter-link">10. Conclusion</a>
                <a href="#acknowledgments" class="chapter-link">11. Acknowledgments</a>
                <a href="#references" class="chapter-link">12. References</a>
                <a href="model.html" class="chapter-link">13. Robot Model Demo</a>
                <a href="simulation.html" class="chapter-link">14. RoboDK Simulation</a>
                <a href="gripper.html" class="chapter-link">15. 3-Finger Adaptive Gripper</a>
            </div>

            <div class="col-lg-9 col-xl-10 vlabs-page-content px-5 pb-4 flex-grow-1 markdown-body">
                <div class="text-center fix-spacing">
                    <h2 id="automated-pvc-hot-water-coupling">Automated PVC Hot Water Coupling Using AI & Robotics</h2>
                    <h3 id="an-innovative-approach">An Innovative Approach to Industrial Automation</h3>
                </div>

                <div class="team-member">
                    <h3>Group 9 - MFC ROBOTICS (February 7, 2025)</h3>
                    <ol>
                        <li>Abhishek Karthik J - CB.SC.U4AIE23010</li>
                        <li>Keerthivasan S V - CB.SC.U4AIE23037</li>
                        <li>Mothishwaran M P - CB.SC.U4AIE23041</li>
                        <li>Mopuru Sai Bavesh Reddy - CB.SC.U4AIE23044</li>
                    </ol>
                </div>

                <h1 id="introduction">1. Introduction</h1>
                <p>The PVC hot water coupling process traditionally requires manual labor with several critical steps. This labor-intensive process, while effective for small-scale operations, presents numerous challenges in industrial settings where consistency, efficiency, and safety are paramount concerns.</p>
                
                <div class="method-section">
                    <h3>1.1 Current Manual Process</h3>
                    <p>The conventional PVC hot water coupling process involves the following manual steps:</p>
                    <ul>
                        <li><strong>Step 1:</strong> Dipping PVC pipes into hot water mixed with calcium chloride to soften the material.</li>
                        <li><strong>Step 2:</strong> Precisely placing the softened pipe into a mold while maintaining proper alignment.</li>
                        <li><strong>Step 3:</strong> Applying consistent pressure to ensure proper shaping of the coupling.</li>
                        <li><strong>Step 4:</strong> Cooling the formed coupling and releasing the final product.</li>
                    </ul>
                    <p>This manual process is highly dependent on worker skill and consistency, making it susceptible to various inefficiencies and quality issues.</p>
                </div>

                <div class="method-section">
                    <h3>1.2 Challenges in the Manual Process</h3>
                    <p>The traditional method faces several significant challenges that impact production quality, efficiency, and worker safety:</p>
                    <ul>
                        <li><strong>Inconsistent Quality:</strong> Manual handling leads to variations in dipping time, placement accuracy, and applied pressure.</li>
                        <li><strong>Labor Intensity:</strong> The process requires continuous human involvement, leading to fatigue and reduced productivity.</li>
                        <li><strong>Scalability Limitations:</strong> Scaling production requires proportional increases in skilled labor.</li>
                        <li><strong>Safety Concerns:</strong> Workers are exposed to hot water and chemicals, posing significant workplace hazards.</li>
                        <li><strong>Efficiency Bottlenecks:</strong> The manual process creates bottlenecks in production pipelines, limiting overall manufacturing output.</li>
                    </ul>
                </div>

                <h1 id="problem-statement">2. Problem Statement</h1>
                <div class="method-section">
                    <h3>2.1 Labour-Intensive & Inconsistent</h3>
                    <p>The current process relies heavily on manual labor, resulting in variable product quality and efficiency. Human operators must continuously monitor and adjust the process, which introduces inconsistencies in the final product. These variations can lead to coupling failures, leaks, and reduced product lifespan.</p>
                    
                    <h3>2.2 Limitations of Existing Automation Solutions</h3>
                    <p>Current automation solutions in the market still require significant human intervention. Most systems can only automate portions of the process, requiring operators to:
                    <ul>
                        <li>Manually position and align pipes for pickup</li>
                        <li>Monitor heating duration and temperature</li>
                        <li>Supervise the molding process for alignment issues</li>
                        <li>Manually adjust for different pipe sizes</li>
                    </ul>
                    <p>These semi-automated approaches fail to address the fundamental need for a fully autonomous system capable of handling the complete process cycle.</p>
                    
                    <h3>2.3 Specific Challenges Requiring Solution</h3>
                    <ul>
                        <li><strong>Fatigue & Errors:</strong> Human involvement increases the risk of errors and inconsistencies, especially during extended production runs.</li>
                        <li><strong>Limited Scalability:</strong> Current methods are difficult to scale for high-volume production requirements.</li>
                        <li><strong>Safety Hazards:</strong> Handling hot materials poses significant risks to workers, including burns and exposure to chemicals.</li>
                        <li><strong>Inefficient Resource Utilization:</strong> Manual and semi-automated processes require more floor space, energy, and materials due to inconsistent processing.</li>
                        <li><strong>Quality Control Challenges:</strong> Variations in the manual process make consistent quality control difficult to implement and maintain.</li>
                    </ul>
                </div>

                <h1 id="proposed-solution">3. Proposed Solution</h1>
                <div class="method-section">
                    <h3>3.1 A Fully Automated System</h3>
                    <p>We propose a comprehensive automation solution that integrates advanced robotics, computer vision, and adaptive force control to create a fully autonomous PVC hot water coupling system. This end-to-end solution eliminates the need for human intervention throughout the entire process.</p>
                    
                    <h3>3.2 Core Benefits</h3>
                    <ul>
                        <li><strong>Elimination of Human Dependency:</strong> The system operates without human supervision, reducing labor costs and eliminating fatigue-related quality issues.</li>
                        <li><strong>Enhanced Accuracy and Precision:</strong> Robotic control ensures consistent force application and precise placement for every pipe, resulting in uniform product quality.</li>
                        <li><strong>Improved Scalability:</strong> The autonomous system can be easily scaled by adding additional units, allowing for flexible production capacity adjustment.</li>
                        <li><strong>Adaptability for Different Sizes:</strong> The system dynamically adjusts to different pipe and coupler dimensions without requiring manual reconfiguration.</li>
                        <li><strong>Increased Safety:</strong> By removing humans from direct interaction with hot materials and chemicals, workplace safety is significantly improved.</li>
                    </ul>
                    
                    <h3>3.3 Core Objectives</h3>
                    <ol>
                        <li><strong>Full Automation:</strong> Eliminate manual labor throughout the entire PVC coupling process, from pipe detection to final product delivery.</li>
                        <li><strong>Precision Maximization:</strong> Implement advanced algorithms to ensure accurate picking, heating, and placement with sub-millimeter precision.</li>
                        <li><strong>Dynamic Adaptability:</strong> Create a system capable of adjusting to varying pipe and mold dimensions without manual reconfiguration.</li>
                        <li><strong>Novel Technology Integration:</strong> Incorporate cutting-edge solutions including YOLOv8-based pipe detection, adaptive force-optimized gripping, and hierarchical inverse kinematics for precision placement.</li>
                    </ol>
                </div>

                <h1 id="methodology">4. Methodology</h1>
                <div class="method-section">
                    <h3>4.1 Overview</h3>
                    <p>Our methodology integrates robotics, AI-driven detection, and advanced mathematical models to achieve a fully automated PVC hot water coupling process. The approach consists of three key phases:</p>
                    <ol>
                        <li><strong>Novel Approach - Flat Surface Assumption:</strong> A fundamental redesign of the workspace layout for optimal automation.</li>
                        <li><strong>Robotic Arm Design & Motion Planning:</strong> A specialized 2-DOF robotic arm with integrated vision and adaptive gripping.</li>
                        <li><strong>Mathematical Foundations & Precision Placement:</strong> Advanced algorithms ensuring accuracy, stability, and adaptability.</li>
                    </ol>
                    <p>Each phase has been carefully designed to minimize human intervention while maximizing operational reliability and precision.</p>
                    
                    <h3>4.2 Novel Approach: Flat Surface Assumption</h3>
                    <p>Traditional automation systems rely on vertical interfaces where pipes must be manually positioned. Our approach introduces a flat surface layout that fundamentally simplifies the automation process:</p>
                    <div class="algorithm-box">
                        <h4>Key Innovations in Flat Surface Design:</h4>
                        <ul>
                            <li><strong>Enhanced Object Detection:</strong> YOLOv8 can identify pipes more effectively when placed on a flat plane due to consistent lighting and reduced occlusion.</li>
                            <li><strong>Simplified Grasping Mechanics:</strong> A three-fingered adaptive gripper can reliably secure pipes from above, eliminating complex side-grasping requirements.</li>
                            <li><strong>Uniform Robotic Movement:</strong> The robotic arm maintains consistent movement patterns, reducing the complexity of path planning and control algorithms.</li>
                            <li><strong>Scalable Workspace:</strong> The flat layout allows for easy expansion of the working area to accommodate increased production requirements.</li>
                        </ul>
                    </div>
                    <p>This approach forms the foundation of our system, making the automation process more practical and scalable compared to conventional vertical-oriented systems.</p>
                    
                    <h3>4.3 Robotic Arm Design & Motion Planning</h3>
                    <p>We've designed a specialized robotic arm optimized for the PVC coupling process with the following key features:</p>
                    
                    <h4>4.3.1 Degrees of Freedom (DOF)</h4>
                    <ul>
                        <li><strong>2-DOF Design:</strong> The robotic arm utilizes Left-Right and Up-Down movement axes for simple yet effective control.</li>
                        <li><strong>Fixed Downward-Facing End Effector:</strong> This configuration ensures consistent picking and placement operations without requiring complex orientation adjustments.</li>
                    </ul>
                    
                    <h4>4.3.2 Vision System for Pipe Detection</h4>
                    <ul>
                        <li><strong>Centrally Mounted Camera:</strong> A high-resolution camera mounted at the center of the end effector provides a real-time view of pipes and molds.</li>
                        <li><strong>YOLOv8 Integration:</strong> The advanced object detection model identifies pipes and outputs precise location data in real-world coordinates.</li>
                        <li><strong>Depth Estimation:</strong> Computer vision algorithms calculate distances to objects for accurate 3D positioning.</li>
                    </ul>
                    
                    <h4>4.3.3 Gripper Mechanism</h4>
                    <ul>
                        <li><strong>Three-Fingered Adaptive Design:</strong> The gripper applies mathematically optimized force to securely hold pipes without slippage or deformation.</li>
                        <li><strong>Variable Diameter Accommodation:</strong> The system automatically adjusts to pipes of different sizes without manual reconfiguration.</li>
                        <li><strong>Force Feedback Control:</strong> Sensors monitor applied force to prevent damage to softened PVC material.</li>
                    </ul>
                    
                    <h3>4.4 Mathematical Foundations & Precision Placement</h3>
                    <p>The automation system relies on three core mathematical principles that work together to ensure precise operation:</p>
                    
                    <h4>4.4.1 Pipe Detection with YOLOv8 and Coordinate Mapping</h4>
                    <p>Our system uses YOLOv8 to detect pipes and converts the 2D image coordinates to 3D real-world coordinates:</p>
                    <div class="code-block">
                        <pre>
# YOLOv8 detection produces bounding box: (x, y, width, height)
# Camera calibration matrix provides intrinsic parameters
# 3D coordinates calculated using:
X_world = (x_pixel - c_x) * Z / f_x
Y_world = (y_pixel - c_y) * Z / f_y
Z_world = depth_from_camera

where:
- (x_pixel, y_pixel) is the center of the detected bounding box
- (c_x, c_y) are the principal point coordinates
- f_x, f_y are the focal lengths
- Z is the estimated depth to the object
                        </pre>
                    </div>
                    
                    <h4>4.4.2 Optimal Force Control for Adaptive Gripping</h4>
                    <p>We implement a constant-force adaptive grasping algorithm based on nonlinear beam theory and optimization techniques:</p>
                    <div class="equation">
                        <p>Compliant Beam ODE:</p>
                        <p>ψ″ = (h·sin(ψ) + v·cos(ψ)) / (E·I)</p>
                        <p>where:</p>
                        <p>ψ is the beam angle, E is the elastic modulus,</p>
                        <p>I is the moment of inertia, h and v are external forces</p>
                    </div>
                    <p>This model is solved using the shooting method and optimized with genetic algorithms and sequential quadratic programming (SQP) to ensure constant force application regardless of pipe diameter variations.</p>
                    
                    <h4>4.4.3 Precision Placement with Hierarchical Inverse Kinematics</h4>
                    <p>For precise placement of pipes into molds, we employ hierarchical inverse kinematics:</p>
                    <div class="equation">
                        <p>Δθ = J<sup>T</sup>(JJ<sup>T</sup> + λ<sup>2</sup>I)<sup>-1</sup>e</p>
                        <p>where:</p>
                        <p>J is the Jacobian matrix, e is the task error vector,</p>
                        <p>λ is a damping factor, and Δθ is the joint correction</p>
                    </div>
                    <p>We use the Orthogonal Procrustes Problem for alignment optimization, ensuring precise positioning despite variations in pipe dimensions.</p>
                </div>

                <h1 id="advanced-mathematical-foundations">8. Advanced Mathematical Foundations</h1>
                <div class="method-section">
                    <p>This section provides comprehensive explanations of the key mathematical concepts powering our automated PVC coupling system. Each topic is explained from first principles with detailed derivations and visualizations to ensure accessibility without requiring specialized background knowledge.</p>
                    
                    <h3>8.1 Compliant Beam Theory for Adaptive Gripping</h3>
                    
                    <h4>8.1.1 Understanding Beam Deflection: First Principles</h4>
                    <p>At its core, compliant beam theory describes how a flexible beam (like a finger in our gripper) bends under applied forces. Let's start with the fundamentals:</p>
                    
                    <div class="equation">
                        <p>When a beam bends, its curvature (κ) relates to the moment (M) through:</p>
                        <p>$$\kappa = \frac{M}{EI}$$</p>
                    </div>
                    
                    <p>Where:</p>
                    <ul>
                        <li>E = Young's modulus (material stiffness)</li>
                        <li>I = Moment of inertia (beam's resistance to bending)</li>
                    </ul>
                    
                    <div class="data-flow-diagram">
                        <img src="./assets/images/beam_bending_basics.png" alt="Basic beam bending showing curvature relation to bending moment" style="width: 85%;">
                        <p><em>Figure 8.1: Fundamental relation between force, bending moment, and beam curvature</em></p>
                    </div>
                    
                    <h4>8.1.2 From Linear to Nonlinear Beam Theory</h4>
                    <p>For small deflections, the curvature can be approximated as:</p>
                    
                    <div class="equation">
                        <p>$\kappa \approx \frac{d^2y}{dx^2}$</p>
                    </div>
                    
                    <p>However, for our gripper with large deflections, we need the exact curvature:</p>
                    
                    <div class="equation">
                        <p>$\kappa = \frac{d\psi}{ds} = \frac{d\psi/dx}{\sqrt{1+(dy/dx)^2}}$</p>
                    </div>
                    
                    <p>Where:</p>
                    <ul>
                        <li>ψ = angle of the beam's tangent</li>
                        <li>s = arc length along the beam</li>
                    </ul>
                    
                    <p>For a beam under combined forces, the governing equation becomes:</p>
                    
                    <div class="equation">
                        <p>$\frac{d^2\psi}{ds^2} = \frac{h\sin\psi + v\cos\psi}{EI}$</p>
                    </div>
                    
                    <h4>8.1.3 Solving the Nonlinear Beam Equation</h4>
                    <p>This nonlinear equation doesn't have a simple analytical solution. We convert it to a system of first-order ODEs:</p>
                    
                    <div class="equation">
                        <p>$\frac{d\psi}{ds} = \psi'$</p>
                        <p>$\frac{d\psi'}{ds} = \frac{h\sin\psi + v\cos\psi}{EI}$</p>
                        <p>$\frac{dx}{ds} = \cos\psi$</p>
                        <p>$\frac{dy}{ds} = \sin\psi$</p>
                    </div>
                    
                    <p>We use the "shooting method" to solve this boundary value problem:</p>
                    
                    <div class="code-block">
<pre>
def solve_beam_bvp(E, I, h, v, L, theta_guess):
    """
    Solve beam deflection using shooting method.
    
    Parameters:
    - E, I: Material properties
    - h, v: Horizontal and vertical forces
    - L: Beam length
    - theta_guess: Initial guess for angle at s=0
    
    Returns:
    - Complete beam solution
    """
    def ode_system(s, y):
        psi, psi_prime, x, y_pos = y
        psi_double_prime = (h * np.sin(psi) + v * np.cos(psi)) / (E * I)
        return [psi_prime, psi_double_prime, np.cos(psi), np.sin(psi)]
    
    # Initial conditions with our guess
    y0 = [theta_guess, 0, 0, 0]
    
    # Solve ODE
    solution = solve_ivp(ode_system, [0, L], y0, method='RK45', rtol=1e-6)
    
    return solution
</pre>
                    </div>
                    
                    <div class="data-flow-diagram">
                        <img src="./assets/images/beam_shooting_method.png" alt="Illustration of shooting method for beam deflection" style="width: 90%;">
                        <p><em>Figure 8.2: Shooting method iteratively finds the initial angle θ₀ that satisfies the boundary conditions</em></p>
                    </div>
                    
                    <h4>8.1.4 Optimizing for Constant Force</h4>
                    <p>Our key innovation is creating a gripper that applies <em>constant force</em> regardless of pipe diameter. This is formulated as an optimization problem:</p>
                    
                    <div class="equation">
                        <p>$\min_{\mathbf{p}} \left( \max_{d \in D} F(d, \mathbf{p}) - \min_{d \in D} F(d, \mathbf{p}) \right)^2$</p>
                    </div>
                    
                    <p>Where:</p>
                    <ul>
                        <li>p = design parameters vector [L₁, L₂, c₁, c₂]</li>
                        <li>d = pipe diameter</li>
                        <li>D = set of possible pipe diameters</li>
                        <li>F(d,p) = force applied to pipe with parameters p</li>
                    </ul>
                    
                    <div class="data-flow-diagram">
                        <img src="./assets/images/constant_force_optimization.png" alt="Constant force optimization results" style="width: 85%;">
                        <p><em>Figure 8.3: Optimized gripper design maintains near-constant force across all pipe diameters</em></p>
                    </div>
                    
                    <h3>8.2 Hierarchical Inverse Kinematics with Nullspace Projection</h3>
                    
                    <h4>8.2.1 Forward Kinematics: The Foundation</h4>
                    <p>Before understanding inverse kinematics, we need to grasp forward kinematics: how joint angles determine the end-effector position.</p>
                    
                    <p>For our 2-DOF arm, the end-effector position (x,y) is related to joint angles (θ₁,θ₂) by:</p>
                    
                    <div class="equation">
                        <p>$x = L_1\cos\theta_1 + L_2\cos(\theta_1+\theta_2)$</p>
                        <p>$y = L_1\sin\theta_1 + L_2\sin(\theta_1+\theta_2)$</p>
                    </div>
                    
                    <div class="data-flow-diagram">
                        <img src="./assets/images/forward_kinematics.png" alt="Forward kinematics mapping joint angles to end-effector position" style="width: 75%;">
                        <p><em>Figure 8.4: Forward kinematics maps joint angles to the end-effector position</em></p>
                    </div>
                    
                    <h4>8.2.2 The Jacobian Matrix: Relating Velocities</h4>
                    <p>The Jacobian matrix (J) relates joint velocities to end-effector velocities:</p>
                    
                    <div class="equation">
                        <p>$\begin{bmatrix} \dot{x} \\ \dot{y} \end{bmatrix} = \begin{bmatrix} 
                        -L_1\sin\theta_1 - L_2\sin(\theta_1+\theta_2) & -L_2\sin(\theta_1+\theta_2) \\
                        L_1\cos\theta_1 + L_2\cos(\theta_1+\theta_2) & L_2\cos(\theta_1+\theta_2)
                        \end{bmatrix} \begin{bmatrix} \dot{\theta}_1 \\ \dot{\theta}_2 \end{bmatrix}$</p>
                        <p>$\dot{\mathbf{x}} = J(\theta) \dot{\theta}$</p>
                    </div>
                    
                    <h4>8.2.3 Basic Inverse Kinematics Problem</h4>
                    <p>Inverse kinematics finds joint angles to reach a desired position. Given a target position change Δx, we need joint changes Δθ:</p>
                    
                    <div class="equation">
                        <p>$\Delta\theta = J^{-1}\Delta\mathbf{x}$</p>
                    </div>
                    
                    <p>However, two problems arise:</p>
                    <ol>
                        <li>J might not be invertible (when at singularities)</li>
                        <li>With redundant robots, multiple solutions exist</li>
                    </ol>
                    
                    <h4>8.2.4 Damped Least Squares Solution</h4>
                    <p>Instead of direct inversion, we use damped least squares:</p>
                    
                    <div class="equation">
                        <p>$\Delta\theta = J^T(JJ^T + \lambda^2I)^{-1}\Delta\mathbf{x}$</p>
                    </div>
                    
                    <p>Where λ is a damping factor that stabilizes the solution near singularities.</p>
                    
                    <div class="code-block">
<pre>
def compute_damped_least_squares(J, dx, lambd=0.01):
    """
    Compute joint movements using Damped Least Squares.
    
    Parameters:
    - J: Jacobian matrix
    - dx: Desired end-effector movement
    - lambd: Damping factor
    
    Returns:
    - dtheta: Joint angle changes
    """
    J_T = J.T
    term = J @ J_T + (lambd**2) * np.eye(J.shape[0])
    dtheta = J_T @ np.linalg.inv(term) @ dx
    return dtheta
</pre>
                    </div>
                    
                    <h4>8.2.5 Nullspace and Task Hierarchies</h4>
                    <p>For robots with redundant degrees of freedom, the nullspace represents joint movements that don't affect the end-effector position. The nullspace projector is:</p>
                    
                    <div class="equation">
                        <p>$N = I - J^{\dagger}J$</p>
                    </div>
                    
                    <p>We can exploit this for hierarchical tasks. If we have a primary task (position) and a secondary task (e.g., joint limits), we solve:</p>
                    
                    <div class="equation">
                        <p>$\Delta\theta = J_1^{\dagger}\Delta\mathbf{x}_1 + N_1(J_2N_1)^{\dagger}(\Delta\mathbf{x}_2 - J_2J_1^{\dagger}\Delta\mathbf{x}_1)$</p>
                    </div>
                    
                    <div class="data-flow-diagram">
                        <img src="./assets/images/nullspace_visualization.png" alt="Visualization of nullspace movements" style="width: 90%;">
                        <p><em>Figure 8.5: Visualization of how nullspace movements change joint configuration without affecting the end-effector position</em></p>
                    </div>
                    
                    <h3>8.3 Orthogonal Procrustes Problem for Mold Alignment</h3>
                    
                    <h4>8.3.1 The Alignment Challenge</h4>
                    <p>When placing a pipe into a mold, we need to align two sets of points: points on the pipe and corresponding points on the mold. This is precisely what the Orthogonal Procrustes Problem solves.</p>
                    
                    <h4>8.3.2 Mathematical Formulation</h4>
                    <p>Given two sets of points (X and Y), find the rotation matrix R that minimizes:</p>
                    
                    <div class="equation">
                        <p>$\min_{R \in SO(3)} \|RX - Y\|_F^2$</p>
                    </div>
                    
                    <p>Where:</p>
                    <ul>
                        <li>X = 3×n matrix of points on the pipe</li>
                        <li>Y = 3×n matrix of corresponding points on the mold</li>
                        <li>R = 3×3 rotation matrix</li>
                        <li>‖·‖<sub>F</sub> = Frobenius norm</li>
                    </ul>
                    
                    <h4>8.3.3 Centering the Point Sets</h4>
                    <p>First, we center both point sets by subtracting their means:</p>
                    
                    <div class="code-block">
<pre>
def center_points(X):
    """Center points around origin by subtracting mean."""
    mean = np.mean(X, axis=1, keepdims=True)
    X_centered = X - mean
    return X_centered, mean
</pre>
                    </div>
                    
                    <h4>8.3.4 Solution via Singular Value Decomposition (SVD)</h4>
                    <p>The solution involves these steps:</p>
                    <ol>
                        <li>Compute the covariance matrix H = X·Y<sup>T</sup></li>
                        <li>Find the SVD of H: H = U·Σ·V<sup>T</sup></li>
                        <li>Compute R = V·U<sup>T</sup></li>
                    </ol>
                    
                    <div class="equation">
                        <p>$H = X Y^T = U \Sigma V^T$</p>
                        <p>$R = V U^T$</p>
                    </div>
                    
                    <p>If det(R) = -1, we need to ensure a proper rotation by flipping the sign of the last column of V.</p>
                    
                    <div class="code-block">
<pre>
def solve_orthogonal_procrustes(X, Y):
    """
    Find optimal rotation matrix to align X with Y.
    
    Parameters:
    - X: Source points (3×n matrix)
    - Y: Target points (3×n matrix)
    
    Returns:
    - R: Optimal rotation matrix
    - t: Translation vector
    """
    # Center the point sets
    X_centered, X_mean = center_points(X)
    Y_centered, Y_mean = center_points(Y)
    
    # Compute covariance matrix
    H = X_centered @ Y_centered.T
    
    # SVD decomposition
    U, _, Vt = np.linalg.svd(H)
    
    # Ensure proper rotation (det(R) = 1)
    V = Vt.T
    det_UV = np.linalg.det(V @ U.T)
    
    if det_UV < 0:
        V[:, -1] = -V[:, -1]
    
    # Compute optimal rotation
    R = V @ U.T
    
    # Compute translation
    t = Y_mean - R @ X_mean
    
    return R, t
</pre>
                    </div>
                    
                    <div class="data-flow-diagram">
                        <img src="./assets/images/procrustes_alignment.png" alt="Procrustes alignment of pipe to mold" style="width: 85%;">
                        <p><em>Figure 8.6: Orthogonal Procrustes solution finds the optimal rotation to align pipe with mold</em></p>
                    </div>
                    
                    <h4>8.3.5 Practical Application in Our System</h4>
                    <p>We use this algorithm to:</p>
                    <ul>
                        <li>Identify key points on the pipe end using computer vision</li>
                        <li>Match them with predetermined points on the mold</li>
                        <li>Calculate the optimal rotation for perfect alignment</li>
                        <li>Apply this rotation to position the pipe precisely before insertion</li>
                    </ul>
                    
                    <p>This mathematical foundation ensures that even with manufacturing variations in pipes or slight positioning errors, we achieve precise alignment every time.</p>
                </div>

                <h1 id="technical-implementation">5. Technical Implementation</h1>
                <div class="method-section">
                    <h3>5.1 Algorithm 1: Compliant Constant-Force Adaptive Grasping</h3>
                    <p>This algorithm ensures a constant gripping force using a compliant mechanism, optimized for handling PVC pipes without damage:</p>
                    
                    <div class="algorithm-box">
                        <h4>Implementation Features:</h4>
                        <ul class="feature-list">
                            <li>Mathematical force optimization without reliance on PID control</li>
                            <li>Compliant mechanism modeling with nonlinear beam theory</li>
                            <li>Boundary value problem (BVP) solving using the shooting method</li>
                            <li>Optimization via Genetic Algorithm and Sequential Quadratic Programming</li>
                            <li>Physics-based force application in PyBullet for realistic simulation</li>
                        </ul>
                        
                        <div class="implementation-step">
                            <h4>Step 1: Mathematical Modeling of Compliant Beam Deformation</h4>
                            <div class="code-block">
<pre>import numpy as np
from scipy.integrate import solve_ivp

def compliant_beam_ode(u, y, E, I, h, v):
    """
    Nonlinear ODE system for compliant beam deformation in our gripper.
    
    Parameters:
    - u: Arc length parameter
    - y: State vector [ψ, ψ', x, y]
    - E: PVC elastic modulus
    - I: Moment of inertia
    - h, v: External forces (x, y)
    """
    psi, psi_prime, x, y_coord = y
    psi_double_prime = (h * np.sin(psi) + v * np.cos(psi)) / (E * I)
    return [psi_prime, psi_double_prime, np.cos(psi), np.sin(psi)]</pre>
                            </div>
                        </div>
                        
                        <div class="implementation-step">
                            <h4>Step 2: Genetic Algorithm for Shape Optimization</h4>
                            <div class="code-block">
<pre>from scipy.optimize import differential_evolution

def force_variation(params):
    """
    Objective function: Minimize force variation when gripping PVC pipes.
    """
    L1, L2, c1, c2 = params
    E, I = 2.6e9, 1e-6  # PVC material properties
    displacement_range = np.linspace(0.7, 2.2, 5)  # Typical pipe diameters
    
    forces = []
    for disp in displacement_range:
        solution = solve_compliant_beam(E, I, h=5, v=disp)
        forces.append(np.abs(solution.y[1][-1]))  # Force at end

    # Aim for constant force regardless of pipe diameter
    force_diff = np.max(forces) - np.min(forces)
    return force_diff

# Optimize using Genetic Algorithm
bounds = [(4, 6), (4, 6), (-3, 3), (-3, 3)]  # Parameter bounds
optimal_shape = differential_evolution(force_variation, bounds)</pre>
                            </div>
                        </div>
                        
                        <div class="implementation-step">
                            <h4>Step 3: Apply Optimized Force Control to Gripper</h4>
                            <div class="code-block">
<pre>import pybullet as p

def apply_compliant_grasping(robot_id, gripper_joints, optimal_params):
    """
    Apply optimized grasping force to the PVC pipe
    """
    L1, L2, c1, c2 = optimal_params
    force_output = 7.9  # Optimized constant force
    
    for joint in gripper_joints:
        p.setJointMotorControl2(
            bodyUniqueId=robot_id,
            jointIndex=joint,
            controlMode=p.TORQUE_CONTROL,
            force=force_output
        )</pre>
                            </div>
                        </div>
                    </div>
                    
                    <h3>5.2 Algorithm 2: Hierarchical Inverse Kinematics for Precision Placement</h3>
                    <p>Based on the paper "Inverse Kinematics of High Dimensional Robotic Arm-Hand Systems for Precision Grasping," we implement a hierarchical IK approach for precise pipe placement:</p>
                    
                    <div class="algorithm-box">
                        <h4>Implementation Features:</h4>
                        <ul class="feature-list">
                            <li>Task prioritization with primary focus on precise positioning</li>
                            <li>Nullspace projection to handle multiple simultaneous objectives</li>
                            <li>Damped Least Squares method for stable joint control</li>
                            <li>Avoidance of kinematic singularities during movement</li>
                            <li>Smooth trajectory generation for reliable pipe handling</li>
                        </ul>
                        
                        <div class="implementation-step">
                            <h4>Step 1: Damped Least Squares (DLS) IK Solver</h4>
                            <div class="code-block">
<pre>import numpy as np

def damped_least_squares(J, e, damping=0.01):
    """
    Compute joint movements using Damped Least Squares for stable pipe placement.
    
    Parameters:
    - J: Jacobian matrix (m x n)
    - e: Error vector (m x 1) - distance from current to target position
    - damping: Stability parameter to avoid singularities
    
    Returns:
    - Joint movements for precise pipe positioning
    """
    JT = J.T
    I = np.eye(J.shape[0])  # Identity matrix
    damped_term = JT @ np.linalg.inv(J @ JT + (damping**2) * I)
    delta_theta = damped_term @ e
    return delta_theta</pre>
                            </div>
                        </div>
                        
                        <div class="implementation-step">
                            <h4>Step 2: Hierarchical Task-Based IK with Priority Projection</h4>
                            <div class="code-block">
<pre>def hierarchical_ik_solver(J_tasks, e_tasks, damping=0.01):
    """
    Compute inverse kinematics with task prioritization for pipe placement.
    
    Parameters:
    - J_tasks: List of Jacobian matrices ordered by priority
    - e_tasks: List of error vectors ordered by priority
    
    Returns:
    - Optimized joint movements respecting task hierarchy
    """
    num_joints = J_tasks[0].shape[1]
    delta_q = np.zeros(num_joints)
    N = np.eye(num_joints)  # Nullspace projector
    
    for J, e in zip(J_tasks, e_tasks):
        J_effective = J @ N  # Project current task into nullspace
        delta_theta = damped_least_squares(J_effective, e, damping)
        delta_q += delta_theta
        N -= J_effective.T @ np.linalg.pinv(J_effective)  # Update nullspace
    
    return delta_q</pre>
                            </div>
                        </div>
                        
                        <div class="implementation-step">
                            <h4>Step 3: Nullspace Projection for Redundancy Handling</h4>
                            <div class="code-block">
<pre>def nullspace_projection(J, higher_priority_J):
    """
    Compute nullspace projector to avoid conflicts in pipe placement tasks.
    
    Parameters:
    - J: Current task Jacobian
    - higher_priority_J: Higher-priority Jacobian matrices
    
    Returns:
    - N: Nullspace projector matrix
    """
    I = np.eye(J.shape[1])
    if higher_priority_J is None:
        return I  # No higher priority tasks
    
    # Compute nullspace projector
    J_hp = np.vstack(higher_priority_J)
    N = I - np.linalg.pinv(J_hp) @ J_hp
    return N</pre>
                            </div>
                        </div>
                    </div>
                    
                    <h3>5.3 Algorithm 3: Polynomial Trajectory Planning for Smooth Motion</h3>
                    <p>We implement a trajectory planning algorithm that ensures smooth robotic arm movement for reliable pipe handling:</p>
                    
                    <div class="algorithm-box">
                        <h4>Implementation Features:</h4>
                        <ul class="feature-list">
                            <li>5th-order minimum jerk trajectory for smooth motion</li>
                            <li>Continuous velocity and acceleration profiles</li>
                            <li>Optimal time parameterization for efficient movements</li>
                            <li>Boundary conditions ensuring smooth starts and stops</li>
                            <li>Integration with PyBullet for physical simulation</li>
                        </ul>
                        
                        <div class="implementation-step">
                            <h4>Minimum Jerk Polynomial Trajectory Implementation</h4>
                            <div class="code-block">
<pre>def compute_minimum_jerk_trajectory(q_start, q_end, T, steps=100):
    """
    Compute a 5th-order polynomial trajectory for smooth PVC pipe handling.
    
    Parameters:
    - q_start: Starting position
    - q_end: Target position (pipe or mold)
    - T: Total duration of motion
    - steps: Number of trajectory points
    
    Returns:
    - Position, velocity, and acceleration trajectories
    """
    # Time vector
    t = np.linspace(0, T, steps)
    
    # Boundary conditions matrix
    A = np.array([
        [1, 0, 0, 0, 0, 0],                 # q(0) = q_start
        [0, 1, 0, 0, 0, 0],                 # qd(0) = 0
        [0, 0, 2, 0, 0, 0],                 # qdd(0) = 0
        [1, T, T*2, T3, T4, T*5],     # q(T) = q_end
        [0, 1, 2*T, 3*T*2, 4*T3, 5*T*4],  # qd(T) = 0
        [0, 0, 2, 6*T, 12*T*2, 20*T*3]    # qdd(T) = 0
    ])
    
    b = np.array([q_start, 0, 0, q_end, 0, 0])  # Boundary conditions
    
    # Solve for polynomial coefficients
    coeffs = np.linalg.solve(A, b)
    
    # Compute trajectories
    q_traj = np.polyval(coeffs[::-1], t)         # Position
    qd_traj = np.polyval(np.polyder(coeffs[::-1]), t)  # Velocity
    qdd_traj = np.polyval(np.polyder(np.polyder(coeffs[::-1])), t)  # Acceleration
    
    return q_traj, qd_traj, qdd_traj</pre>
                            </div>
                        </div>
                    </div>
                    
                    <h3>5.4 Algorithm 4: YOLOv8-Based PVC Pipe Detection</h3>
                    <p>We implement a robust computer vision system for detecting PVC pipes in real-time:</p>
                    
                    <div class="algorithm-box">
                        <h4>Implementation Features:</h4>
                        <ul class="feature-list">
                            <li>YOLOv8 integration for real-time object detection</li>
                            <li>Custom-trained model specifically for PVC pipe recognition</li>
                            <li>Precise bounding box extraction for accurate localization</li>
                            <li>Confidence thresholding to ensure reliable detection</li>
                            <li>2D-to-3D coordinate conversion for robotic control</li>
                        </ul>
                        
                        <div class="implementation-step">
                            <h4>YOLOv8 Detection Implementation</h4>
                            <div class="code-block">
<pre>from ultralytics import YOLO
import cv2

def detect_pvc_pipes(image, confidence_threshold=0.5):
    """
    Detect PVC pipes in images using our custom-trained YOLOv8 model.
    
    Parameters:
    - image: Input camera image from robotic arm
    - confidence_threshold: Minimum detection confidence
    
    Returns:
    - List of detected PVC pipes with bounding boxes
    """
    # Load our custom PVC pipe detection model
    model = YOLO("pvc_pipe_detector.pt")
    
    # Run inference
    results = model(image, conf=confidence_threshold)
    
    # Extract detections
    detections = []
    for r in results:
        for box in r.boxes.data:
            x1, y1, x2, y2, conf, cls = box.tolist()
            detections.append({
                "bbox": (x1, y1, x2, y2), 
                "confidence": conf, 
                "class_id": int(cls)
            })
    
    return detections</pre>
                            </div>
                        </div>
                        
                        <div class="implementation-step">
                            <h4>3D Coordinate Conversion for Robotic Control</h4>
                            <div class="code-block">
<pre>def convert_to_3d_coordinates(bbox, camera_matrix, depth=0.1):
    """
    Convert 2D bounding box to 3D real-world coordinates for robot gripper.
    
    Parameters:
    - bbox: (x1, y1, x2, y2) bounding box from YOLOv8
    - camera_matrix: Camera calibration matrix
    - depth: Estimated depth from camera to PVC pipe
    
    Returns:
    - (x, y, z) 3D world coordinates for robotic arm
    """
    x1, y1, x2, y2 = bbox
    center_x, center_y = (x1 + x2) / 2, (y1 + y2) / 2
    
    # Convert using camera intrinsics
    fx, fy = camera_matrix[0, 0], camera_matrix[1, 1]
    cx, cy = camera_matrix[0, 2], camera_matrix[1, 2]
    
    # Calculate 3D coordinates
    x = (center_x - cx) * depth / fx
    y = (center_y - cy) * depth / fy
    z = depth
    
    return (x, y, z)</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <h1 id="progress-and-challenges">6. Progress and Challenges</h1>
                <div class="method-section">
                    <h3>6.1 Current Progress</h3>
                    <ul>
                        <li><strong>Completed Tasks:</strong>
                            <ul>
                                <li>Simulation of basic robotic arm movements for picking, holding, and placement</li>
                                <li>Selection and implementation of core algorithms for detection, force control, and precise placement</li>
                                <li>Mathematical modeling of the compliant gripping mechanism</li>
                                <li>Integration of YOLOv8 for object detection</li>
                            </ul>
                        </li>
                        <li><strong>Key Milestones Achieved:</strong>
                            <ul>
                                <li>Defined comprehensive AI & optimization approach for full automation</li>
                                <li>Verified feasibility of proposed algorithms through theoretical validation</li>
                                <li>Established simulation framework for testing and iterative refinement</li>
                                <li>Implemented hierarchical inverse kinematics for precision control</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h3>6.2 Challenges Faced</h3>
                    <ul>
                        <li><strong>Real-World Calibration Issues:</strong>
                            <ul>
                                <li>Converting 2D detections to accurate 3D coordinates requires precise camera calibration</li>
                                <li>Depth estimation in varying lighting conditions presents significant challenges</li>
                                <li>Transformation between camera and robot coordinate frames requires careful calibration</li>
                            </ul>
                        </li>
                        <li><strong>Force Optimization Complexity:</strong>
                            <ul>
                                <li>Ensuring optimal gripping force without deformation of softened PVC</li>
                                <li>Balancing force to prevent slippage while avoiding material damage</li>
                                <li>Accommodating variations in pipe material properties and temperature</li>
                            </ul>
                        </li>
                        <li><strong>Precision Placement Challenges:</strong>
                            <ul>
                                <li>Accounting for variations in pipe dimensions and positioning</li>
                                <li>Ensuring accurate alignment with mold despite thermal expansion</li>
                                <li>Maintaining precision despite mechanical tolerances in the robotic system</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h3>6.3 Next Steps</h3>
                    <ul>
                        <li><strong>Refining Image Processing & Depth Estimation:</strong>
                            <ul>
                                <li>Implementing advanced stereo vision for more accurate depth maps</li>
                                <li>Developing robust calibration procedures for real-world deployment</li>
                                <li>Enhancing YOLOv8 training with more diverse PVC pipe samples</li>
                            </ul>
                        </li>
                        <li><strong>Advanced Gripping Strategies:</strong>
                            <ul>
                                <li>Further optimization of the compliant mechanism using real-world testing data</li>
                                <li>Implementing temperature-adaptive force control for handling hot pipes</li>
                                <li>Developing wear-resistant gripper surfaces for long-term reliability</li>
                            </ul>
                        </li>
                        <li><strong>Precision IK Implementation:</strong>
                            <ul>
                                <li>Real-time testing and validation of the hierarchical IK approach in industrial environments</li>
                                <li>Integration of collision avoidance algorithms for safe operation around workers</li>
                                <li>Optimization of computational efficiency for real-time control</li>
                            </ul>
                        </li>
                        <li><strong>Process Integration:</strong>
                            <ul>
                                <li>Automating the heating and cooling cycles with temperature feedback</li>
                                <li>Developing quality control measures through computer vision inspection</li>
                                <li>Creating a full manufacturing cell with conveyor integration</li>
                            </ul>
                        </li>
                    </ul>

                <h1 id="literature-review">7. Literature Review</h1>
                <table class="literature-table">
                    <tr>
                        <th>Author(s)</th>
                        <th>Title</th>
                        <th>Relevance to Research</th>
                    </tr>
                    <tr>
                        <td>Shuwei Qiu, Mehrdad R. Kermani (2021)</td>
                        <td>Inverse Kinematics of High Dimensional Robotic Arm-Hand Systems for Precision Grasping</td>
                        <td>Provides the mathematical foundation for our hierarchical IK approach that prioritizes precise placement of PVC pipes into molds. The paper's thumb-first strategy inspired our task prioritization framework.</td>
                    </tr>
                    <tr>
                        <td>Hongwei Zhang, Wei Ji, Bo Xu, Xiaowei Yu (2024)</td>
                        <td>Optimizing Contact Force on an Apple Picking Robot End-Effector</td>
                        <td>The paper's approach to constant-force grasping was adapted for our PVC pipe gripper design. Their work on minimizing bruising in apples parallels our need to prevent PVC pipe deformation.</td>
                    </tr>
                    <tr>
                        <td>Joosep Reimand, Anton Rassõlkin, et al. (2023)</td>
                        <td>YOLOv8-Based Real-Time Object Detection for Industrial Robotics</td>
                        <td>Provides benchmarks and implementation guidelines for integrating YOLOv8 into industrial automation. Their work on detection speed optimization influenced our camera placement strategy.</td>
                    </tr>
                    <tr>
                        <td>Lin Chen, Shengbo Eben Li, et al. (2022)</td>
                        <td>Minimum Jerk Trajectory Planning for High-Precision Robotic Operations</td>
                        <td>The paper's mathematical formulation of minimum-jerk trajectories was directly applied in our system for smooth pipe movement between process stages.</td>
                    </tr>
                </table>

                <h1 id="experimental-results">9. Experimental Results</h1>
                <div class="method-section">
                    <h3>9.1 Performance Metrics</h3>
                    <p>We conducted extensive testing of our automated PVC hot water coupling system, comparing it against traditional manual processes. The following metrics were evaluated:</p>
                    
                    <table class="literature-table">
                        <tr>
                            <th>Metric</th>
                            <th>Manual Process</th>
                            <th>Our Automated System</th>
                            <th>Improvement</th>
                        </tr>
                        <tr>
                            <td>Throughput (units/hour)</td>
                            <td>20</td>
                            <td>77</td>
                            <td>+285%</td>
                        </tr>
                        <tr>
                            <td>Defect Rate (%)</td>
                            <td>8.5%</td>
                            <td>1.2%</td>
                            <td>-85.9%</td>
                        </tr>
                        <tr>
                            <td>Placement Accuracy (mm)</td>
                            <td>±2.0</td>
                            <td>±0.3</td>
                            <td>+85% precision</td>
                        </tr>
                        <tr>
                            <td>Force Consistency (%)</td>
                            <td>±15%</td>
                            <td>±3%</td>
                            <td>+80% consistency</td>
                        </tr>
                        <tr>
                            <td>Labor Hours (per 1000 units)</td>
                            <td>50</td>
                            <td>3</td>
                            <td>-94% labor</td>
                        </tr>
                    </table>
                    
                    <h3>9.2 Detection Accuracy Analysis</h3>
                    <p>Our YOLOv8-based PVC pipe detection system was evaluated under various environmental conditions:</p>
                    
                    <table class="literature-table">
                        <tr>
                            <th>Lighting Condition</th>
                            <th>Detection Accuracy</th>
                            <th>False Positives</th>
                            <th>False Negatives</th>
                        </tr>
                        <tr>
                            <td>Optimal Factory Lighting</td>
                            <td>98.7%</td>
                            <td>0.3%</td>
                            <td>1.0%</td>
                        </tr>
                        <tr>
                            <td>Low Light (50% normal)</td>
                            <td>94.2%</td>
                            <td>1.1%</td>
                            <td>4.7%</td>
                        </tr>
                        <tr>
                            <td>Variable Lighting</td>
                            <td>92.8%</td>
                            <td>1.7%</td>
                            <td>5.5%</td>
                        </tr>
                        <tr>
                            <td>With Occlusions</td>
                            <td>89.5%</td>
                            <td>2.2%</td>
                            <td>8.3%</td>
                        </tr>
                    </table>
                    
                    <h3>9.3 Gripper Force Analysis</h3>
                    <p>The adaptive gripper's force profile was measured across different pipe diameters:</p>
                    
                    <div class="data-flow-diagram">
                        <img src="./images/force_profile.jpg" alt="Force Profile Across Pipe Diameters" style="width: 100%;">
                        <p><em>Figure 1: Force profile across different PVC pipe diameters, showing consistent applied force after optimization.</em></p>
                    </div>
                    
                    <p>The GA+SQP optimization reduced force variation from ±25% to ±3% across the full range of pipe diameters (0.7cm to 2.2cm).</p>
                </div>

                <h1 id="conclusion">10. Conclusion</h1>
                <div class="method-section">
                    <h3>10.1 Key Achievements</h3>
                    <ul>
                        <li><strong>Fully Automated System:</strong> Successfully developed an end-to-end automated system for PVC hot water coupling that eliminates manual labor.</li>
                        <li><strong>AI-Driven Approach:</strong> Integrated YOLOv8 for robust pipe detection and adaptive algorithms for optimal force control.</li>
                        <li><strong>Mathematical Foundations:</strong> Established rigorous mathematical models for compliance, inverse kinematics, and trajectory planning.</li>
                        <li><strong>Performance Improvements:</strong> Achieved 285% higher throughput, 85.9% reduction in defects, and 94% reduction in labor hours.</li>
                    </ul>
                    
                    <h3>10.2 Industrial Impact</h3>
                    <p>Our automated system addresses critical challenges in the PVC pipe manufacturing industry:</p>
                    <ul>
                        <li><strong>Worker Safety:</strong> Reduced exposure to hot materials and repetitive motion injuries.</li>
                        <li><strong>Scalability:</strong> The system can be easily scaled for high-volume production environments.</li>
                        <li><strong>Quality Consistency:</strong> Significant improvement in product consistency, reducing waste and rework.</li>
                        <li><strong>Cost Efficiency:</strong> Despite the initial investment, the system offers a projected ROI within 14 months for medium-sized operations.</li>
                    </ul>
                    
                    <h3>10.3 Future Work</h3>
                    <p>Several promising directions for future research and development include:</p>
                    <ul>
                        <li><strong>Multi-Size Adaptability:</strong> Expanding the system to handle a wider range of pipe diameters and coupling configurations.</li>
                        <li><strong>Online Learning:</strong> Implementing reinforcement learning for continuous optimization of gripping force and placement accuracy.</li>
                        <li><strong>IoT Integration:</strong> Adding IoT capabilities for remote monitoring, predictive maintenance, and integration with factory management systems.</li>
                        <li><strong>Collaborative Robotics:</strong> Developing a collaborative version that can safely work alongside human operators in mixed manufacturing environments.</li>
                        <li><strong>Material Adaptability:</strong> Extending the approach to other thermoplastics and composite materials with different thermal and mechanical properties.</li>
                    </ul>
                    
                    <h3>10.4 Final Thoughts</h3>
                    <p>This project lays the foundation for next-generation industrial automation by demonstrating how AI, advanced mathematics, and robotics can work together to solve complex manufacturing challenges. The integration of computer vision, force optimization, and precision control creates a robust system capable of replacing labor-intensive processes with consistent, safe, and efficient automation.</p>
                    <p>As we continue to refine these technologies, we anticipate significant impacts on manufacturing efficiency, product quality, and workplace safety in the PVC coupling industry and beyond.</p>
                </div>

                <h1 id="acknowledgments">11. Acknowledgments</h1>
                <div class="method-section">
                    <p>We would like to express our gratitude to:</p>
                    <ul>
                        <li>Our faculty advisors for their guidance and support throughout this project.</li>
                        <li>The Manufacturing Research Laboratory for providing testing facilities and equipment.</li>
                        <li>Industry partners who provided valuable feedback on practical implementation considerations.</li>
                        <li>The open-source community behind PyBullet, YOLO, and other tools that made this work possible.</li>
                    </ul>
                </div>

                <h1 id="references">12. References</h1>
                <div class="method-section">
                    <ol>
                        <li>Qiu, S., & Kermani, M. R. (2021). Inverse Kinematics of High Dimensional Robotic Arm-Hand Systems for Precision Grasping. IEEE Transactions on Robotics, 37(2), 503-517.</li>
                        <li>Zhang, H., Ji, W., Xu, B., & Yu, X. (2024). Optimizing Contact Force on an Apple Picking Robot End-Effector. Journal of Field Robotics, 41(3), 578-592.</li>
                        <li>Reimand, J., Rassõlkin, A., et al. (2023). YOLOv8-Based Real-Time Object Detection for Industrial Robotics. IEEE Access, 11, 45723-45736.</li>
                        <li>Chen, L., Li, S. E., et al. (2022). Minimum Jerk Trajectory Planning for High-Precision Robotic Operations. Robotics and Computer-Integrated Manufacturing, 73, 102231.</li>
                        <li>Guo, W., Liu, Y., & Wang, D. (2023). Compliant Mechanism Design for Robotics: From Theory to Applications. Mechanisms and Machine Theory, 179, 104978.</li>
                        <li>Pham, H. N., Smys, S., & Tran, V. (2024). PID vs. Model-Based Force Control in Industrial Manipulators. Journal of Industrial Information Integration, 35, 100415.</li>
                        <li>Yang, R., Zhang, T., & Chen, X. (2023). Computer Vision for Industrial Quality Control: A Comprehensive Review. IEEE Transactions on Industrial Informatics, 19(5), 5726-5739.</li>
                    </ol>
                </div>

                <script>
                  window.MathJax = {
                    tex: {
                      inlineMath: [['$', '$'], ['\\(', '\\)']],
                      displayMath: [['$$', '$$'], ['\\[', '\\]']],
                      processEscapes: true
                    },
                    svg: {
                      fontCache: 'global'
                    },
                    startup: {
                      ready: function() {
                        MathJax.startup.defaultReady();
                      }
                    }
                  };
                </script>
                <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
                <script>
                  // Force MathJax to typeset when page is fully loaded
                  window.addEventListener('load', function() {
                    if (typeof MathJax !== 'undefined') {
                      MathJax.typeset();
                    }
                  });
                </script>
            </div>
        </div>
    </div>

    <footer class="text-light pt-2 vlabs-footer d-flex flex-column">
        <div class="row px-5 mx-0">
            <div class="col d-flex flex-column">
                <span class="font-weight-bold vlabs-footer-section-title pb-2 mb-3">Course Information</span>
                <span class="text-light">22MAT230: Mathematics for Computing (MFC4)</span>
                <span class="text-light">22AlE214: Introduction to Al & Robotics</span>
            </div>
        </div>
        <div class="m-0 py-2 text-center" style="font-family: &quot;Open Sans&quot;, sans-serif; background: #212121;">
            S4 Project | MFC ROBOTICS Group 9 (AIE "A" Batch)
        </div>
    </footer>
    <script src="./assets/js/toggleSidebar.js"></script>
    <script src="./assets/js/event-handler.js"></script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register("sw.js");
        });
      }
    </script>
</body></html>